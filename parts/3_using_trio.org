* Development
  :PROPERTIES:
  :reveal_extra_attr: data-state="no-toc-progress" class="center"
  :html_headline_class: sectitle
  :END:
  {{{secname(Using Trio)}}}

** Read the docs

{{{BR}}}
{{{BR}}}

#+ATTR_REVEAL: :frag (none fade-in)
- https://trio.readthedocs.io/
  {{{BR}}}{{{BR}}}
- No, seriously, the docs are excellent
  {{{BR}}}{{{BR}}}
- Okay, I'll talk about trio a bit more

** From the very beginning

#+ATTR_REVEAL: :code_attribs data-line-numbers
#+INCLUDE: "../code/3_sync_vs_async.py" src python

- Async code can call sync code
  #+ATTR_REVEAL: :frag fade-in :frag-idx 1
  ... but don't call anything that blocks
- Sync code can't call async code
  #+ATTR_REVEAL: :frag fade-in :frag-idx 2
  ... but frameworks like Trio are a special case

** Getting it wrong

#+ATTR_REVEAL: :code_attribs data-line-numbers="|8|11"
#+INCLUDE: "../code/3_mistakes.py" src python

{{{BR}}}
Debugging a forgotten ~await~ is annoying. ðŸ˜¿

{{{BR}}}
Trio provides some debugging tools: ~trio.abc.Instrument~

#+BEGIN_NOTES
- Symptom of building structure on top of ~goto~.
- See docs for ~trio.abc.Instrument~.
#+END_NOTES

** Nurseries: actual concurrency

#+ATTR_REVEAL: :code_attribs data-line-numbers="|3-7|11-14"
#+INCLUDE: "../code/3_nursery.py" src python

{{{BR}}}
A nursery block doesn't exit until all child tasks are complete.

#+BEGIN_NOTES
- A nursery is an async context manager.
- Also async ~nursery.start~ for tasks that need setup.
#+END_NOTES

** Timeouts

#+ATTR_REVEAL: :code_attribs data-line-numbers="|4-11|12-19|"
#+INCLUDE: "../code/3_timeouts.py" src python

#+BEGIN_NOTES
- Checkpoints and cancellation.
- 4-11: ~move_on_after~ will cancel everything inside after the timeout.
- 12-19: ~fail_after~ does the same, but raises.
  - Timeout must be around nursery, not inside.
- Also ~_at~ variants for deadline rather than timeout.
#+END_NOTES

** Errors and cancellation

#+ATTR_REVEAL: :code_attribs data-line-numbers
#+INCLUDE: "../code/3_cancellation.py" src python

#+BEGIN_NOTES
- A nursery is a cancel scope.
- When a child task (including the body) raises, all children are cancelled.
- See docs for ~MultiError~.
- Tracebacks that make sense!
#+END_NOTES

** Other features

#+ATTR_REVEAL: :frag (fade-in)
- Task-local storage
- Communication between tasks
  - Events
  - Channels
  - Locks, semaphores, ...
- Async generators (with caveats)
- Threads (if you must)
- Async filesystem operations
- Subprocesses

** Bonus: echo server

#+ATTR_REVEAL: :code_attribs data-line-numbers="|7-10|14-15|6,11-12|"
#+INCLUDE: "../code/3_echo_server.py" src python

#+BEGIN_NOTES
- 7-10: Iterate over the network stream, echoing each block of data.
  - Iter ends when stream is closed.
- 14-15: Start an ~echo_server~ task for each connection.
- 6,11-12: Handle (normal) exceptions per-connection.
#+END_NOTES

** Bonus: echo client

#+ATTR_REVEAL: :code_attribs data-line-numbers="|4-8|10-14|18-22|" style="line-height: 1.0em"
#+INCLUDE: "../code/3_echo_client.py" src python

#+BEGIN_NOTES
- 4-8: Send task: sends data every second.
- 10-14: Receive task: prints any data received.
- 18-22: Opens a stream, starts concurrent send and receive tasks on it.
  - Stream context manager closes stream, like ~with file~ but async.
#+END_NOTES

** Bonus: Flow control

Why didn't we write the client like this?

#+ATTR_REVEAL: :code_attribs data-line-numbers="|5|4|"
#+INCLUDE: "../code/3_flow_client.py" src python

#+BEGIN_NOTES
- 5: ~receive_some~ may not receive all data.
  - Networks are complicated and horrible.
  - If this happens a lot, data can fill buffers, block sender, etc.
- 4: ~send_all~ may block.
  - While blocked, we don't receive.
  - Which can cause/exacerbate receive backlog.
- These two things can interact and lead to client/server deadlock.
- Not as much of a problem for server because it sends what it receives.
#+END_NOTES
